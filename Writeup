The code is relatively simple due to the nature of the Densely-Packed BCD conversion, as most of the cases in a given 3-digit number could be hardcoded.
However, in an attempt to reduce the amount of bloat within the codebase, most of the BCD cases were not decided through an obscene amount of if statements.
That is to say, the code was written in a way that allowed for minimal hard coding.

The main difficulty when it comes to quadprecision decimal floating point conversion is the large volume of bits that the output requires, which makes it much harder to trace under normal circumstances.
Thus, it was decided to implement the functions first in single precision format, which is far easier to trace, before scaling it into quadprecision.
Upon scaling, however, it was realized that scaling single precision to double, quadruple, or any precision for that matter was not too difficult, as the only things that change are the parameters that would decide the bias and the number of bits per field.
As such, these parameters were calculated using formulated equations in order to:
  1.) support future portability into higher or lower precisions and to
  2.) reduce the amount of bloat generated by further conditional statements.

Another issue, though this is more relevant to the non-required binary floating point output than the decimal floating point output, was that numbers that are too large or too small are unsupported with traditional data types.
This was easily circumvented with the decimal floating point, as the binary representations of the mantissa are based on the provided digits and not their actual values.
That is to say, in order to convert the digits into their respective densely packed BCD representations, they only needed to be stored in a string, wherein the characters can be iterated upon to find the BCD representation of every three digits.
For the binary floating point representation, however, the actual value is needed, thus requiring the use of larger data types in order to store the input.
Fortunately, in most high level programming languages, including Javascript, there is often a library that can store bigger numbers.
In the case of this project in particular, this library is the bignumber library, which stores numbers as strings and therefore eliminates the restriction on the values.
However, since the bignumber library is a nodeJS module, and setting up nodeJS just for this singular library is impractical, the library's logic was extracted and transferred to a local file, allowing for easy use without the need to install other modules.
